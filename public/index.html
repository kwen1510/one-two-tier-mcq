<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Collaborative MCQ Workspace ‚Äì Student</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --brand: #4b74ff;
        --brand-accent: #2f4fdb;
        --bg: #f5f7fb;
        --card: #ffffff;
        --text: #21263c;
        --muted: #6e7591;
        --success: #1c9c6d;
        --danger: #cc3a51;
        --border-radius: 18px;
        --shadow: 0 16px 40px rgba(29, 49, 85, 0.08);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
        background: radial-gradient(circle at 20% 20%, rgba(75, 116, 255, 0.14), transparent 55%),
          radial-gradient(circle at 80% 0%, rgba(28, 156, 109, 0.12), transparent 45%),
          var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 32px 16px;
        overflow-x: hidden;
      }

      .app-shell {
        width: min(1080px, 100%);
        display: grid;
        gap: 24px;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(255, 255, 255, 0.75);
        backdrop-filter: blur(20px);
        border-radius: var(--border-radius);
        padding: 20px 28px;
        box-shadow: var(--shadow);
      }

      header .title-group h1 {
        margin: 0;
        font-size: 1.6rem;
        font-weight: 700;
      }

      header .title-group p {
        margin: 4px 0 0;
        color: var(--muted);
      }

      header .stage-chip {
        padding: 10px 18px;
        border-radius: 999px;
        font-weight: 600;
        background: rgba(75, 116, 255, 0.12);
        color: var(--brand-accent);
        display: inline-flex;
        align-items: center;
        gap: 10px;
      }

      header .stage-chip span {
        font-size: 1.1rem;
      }

      .card {
        background: var(--card);
        border-radius: var(--border-radius);
        padding: 28px;
        box-shadow: var(--shadow);
      }

      .card h2 {
        margin-top: 0;
        font-size: 1.4rem;
        margin-bottom: 8px;
      }

      .card p.subtitle {
        margin-top: 0;
        margin-bottom: 24px;
        color: var(--muted);
      }

      .grid-two {
        display: grid;
        gap: 24px;
      }

      @media (min-width: 900px) {
        .grid-two {
          grid-template-columns: 3fr 2fr;
        }
      }

      label {
        font-weight: 600;
        display: block;
        margin-bottom: 8px;
      }

      input[type="text"],
      textarea {
        width: 100%;
        border-radius: 12px;
        border: 1px solid rgba(33, 38, 60, 0.12);
        padding: 12px 16px;
        font-size: 1rem;
        font-family: inherit;
        transition: border 0.2s ease, box-shadow 0.2s ease;
      }

      input[type="text"]:focus,
      textarea:focus {
        outline: none;
        border-color: rgba(75, 116, 255, 0.45);
        box-shadow: 0 0 0 4px rgba(75, 116, 255, 0.15);
      }

      textarea {
        resize: vertical;
        min-height: 120px;
      }

      button {
        border: none;
        border-radius: 12px;
        font-size: 1rem;
        font-weight: 600;
        padding: 12px 20px;
        cursor: pointer;
        transition: transform 0.1s ease, box-shadow 0.2s ease, background 0.2s ease;
        font-family: inherit;
      }

      button.primary {
        background: linear-gradient(135deg, var(--brand) 0%, var(--brand-accent) 100%);
        color: #fff;
        box-shadow: 0 12px 24px rgba(75, 116, 255, 0.24);
      }

      button.primary:disabled {
        cursor: not-allowed;
        opacity: 0.6;
        box-shadow: none;
      }

      button.secondary {
        background: rgba(33, 38, 60, 0.06);
        color: var(--text);
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
      }

      .hidden {
        display: none !important;
      }

      .status-banner {
        border-radius: 12px;
        padding: 14px 16px;
        background: rgba(75, 116, 255, 0.12);
        color: var(--brand-accent);
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .status-banner.error {
        background: rgba(204, 58, 81, 0.12);
        color: var(--danger);
      }

      .status-banner.success {
        background: rgba(28, 156, 109, 0.12);
        color: var(--success);
      }

      .option-list {
        display: grid;
        gap: 12px;
        margin-top: 16px;
      }

      .option-tile {
        border: 1px solid rgba(33, 38, 60, 0.12);
        border-radius: 14px;
        padding: 16px 18px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: border 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
      }

      .option-tile input {
        width: 20px;
        height: 20px;
      }

      .option-tile.selected {
        border-color: rgba(75, 116, 255, 0.6);
        background: rgba(75, 116, 255, 0.08);
        box-shadow: 0 8px 18px rgba(75, 116, 255, 0.18);
      }

      .sub-card {
        border: 1px solid rgba(33, 38, 60, 0.08);
        border-radius: 12px;
        padding: 16px;
        background: rgba(255, 255, 255, 0.72);
      }

      .group-members {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
      }

      .pill {
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(33, 38, 60, 0.08);
        font-size: 0.9rem;
      }

      .summary-grid {
        display: grid;
        gap: 16px;
      }

      .canvas-card {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .canvas-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .canvas-workspace {
        position: relative;
        display: grid;
        gap: 18px;
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto minmax(320px, 1fr);
      }

      .canvas-toolbar {
        position: sticky;
        top: 0;
        z-index: 2;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(16px);
        border-radius: 18px;
        padding: 14px 18px;
        box-shadow: 0 12px 24px rgba(75, 116, 255, 0.12);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 18px;
        flex-wrap: wrap;
      }

      .canvas-tool-button.is-active {
        background: linear-gradient(135deg, var(--brand) 0%, var(--brand-accent) 100%);
        color: #fff;
        box-shadow: 0 8px 18px rgba(75, 116, 255, 0.2);
      }

      .canvas-tool-group {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .canvas-tool-button {
        border: none;
        border-radius: 12px;
        padding: 10px 16px;
        background: rgba(33, 38, 60, 0.06);
        color: var(--text);
        font-size: 0.95rem;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
      }

      .canvas-tool-button .icon {
        font-size: 1rem;
      }

      .canvas-tool-button.primary {
        background: linear-gradient(135deg, var(--brand) 0%, var(--brand-accent) 100%);
        color: #fff;
        box-shadow: 0 8px 18px rgba(75, 116, 255, 0.2);
      }

      .canvas-tool-button:hover {
        transform: translateY(-1px);
      }

      .canvas-tool-button:focus-visible {
        outline: 3px solid rgba(75, 116, 255, 0.3);
        outline-offset: 2px;
      }

      .canvas-tool-button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        box-shadow: none;
      }

      .canvas-surface {
        background: radial-gradient(circle at 20% 20%, rgba(75, 116, 255, 0.08), transparent 55%),
          var(--card);
        border-radius: 22px;
        box-shadow: inset 0 0 0 1px rgba(33, 38, 60, 0.08);
        position: relative;
        min-height: 360px;
        overflow: hidden;
        display: flex;
        padding: 18px;
      }

      .canvas-board {
        position: relative;
        flex: 1;
        border-radius: 18px;
        background: #fff;
        box-shadow: 0 18px 36px rgba(33, 38, 60, 0.08);
        overflow: hidden;
      }

      .canvas-board canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .canvas-placeholder {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 12px;
        color: var(--muted);
        text-align: center;
        padding: 24px;
        pointer-events: none;
      }

      .canvas-placeholder strong {
        color: var(--text);
        font-size: 1.1rem;
      }

      @media (max-width: 1024px) {
        .canvas-workspace {
          grid-template-columns: min(220px, 32vw) minmax(0, 1fr);
          grid-template-rows: minmax(340px, 1fr);
          align-items: start;
        }

        .canvas-toolbar {
          position: sticky;
          top: 24px;
          align-self: start;
          height: auto;
          flex-direction: column;
          justify-content: flex-start;
          gap: 14px;
          min-width: 0;
        }

        .canvas-tool-group {
          flex-direction: column;
          align-items: stretch;
        }

        .canvas-tool-button {
          width: 100%;
          justify-content: center;
        }

        .canvas-surface {
          min-height: 420px;
        }
      }

      @media (max-width: 720px) {
        .canvas-workspace {
          grid-template-columns: minmax(0, 1fr);
          grid-template-rows: auto minmax(300px, 1fr);
        }

        .canvas-toolbar {
          flex-direction: row;
          align-items: center;
          justify-content: flex-start;
          top: 0;
        }

        .canvas-tool-group {
          flex-direction: row;
        }

        .canvas-tool-button {
          width: auto;
        }
      }

      @media (min-width: 768px) {
        .summary-grid {
          grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }
      }

      .progress-track {
        width: 100%;
        height: 8px;
        border-radius: 999px;
        background: rgba(33, 38, 60, 0.08);
        overflow: hidden;
        margin-top: 8px;
      }

      .progress-bar {
        height: 100%;
        border-radius: 999px;
        background: linear-gradient(135deg, var(--brand) 0%, var(--brand-accent) 100%);
        transition: width 0.4s ease;
      }

      .muted {
        color: var(--muted);
        font-size: 0.95rem;
      }

      ul.roster {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      ul.roster li {
        background: rgba(33, 38, 60, 0.08);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header>
        <div class="title-group">
          <h1>Collaborative MCQ Workspace</h1>
          <p>Join the live session, respond, discuss, and explain with your peers.</p>
        </div>
        <div class="stage-chip">
          <small>Stage</small>
          <span id="stageLabel">Lobby</span>
        </div>
      </header>

      <div class="grid-two">
        <section id="joinCard" class="card">
          <h2>Join a Session</h2>
          <p class="subtitle">
            Enter the session code provided by your facilitator and let us know your name.
          </p>
          <div class="form-group">
            <label for="codeInput">Session Code</label>
            <input
              id="codeInput"
              type="text"
              placeholder="ABC123"
              autocomplete="off"
              maxlength="12"
            />
          </div>
          <div class="form-group">
            <label for="nameInput">Your Name</label>
            <input
              id="nameInput"
              type="text"
              placeholder="e.g. Taylor"
              autocomplete="name"
            />
          </div>
          <button id="joinButton" class="primary" type="button">Join Session</button>
          <div id="joinFeedback" class="status-banner hidden" role="status"></div>
        </section>

        <section id="statusCard" class="card hidden">
          <h2>Live Session Details</h2>
          <p class="subtitle">Stay in sync with the facilitator and your peers.</p>
          <div class="sub-card">
            <strong>Session Code:</strong>
            <div id="sessionCodeDisplay" style="font-size:1.4rem;font-weight:700;margin-top:4px;letter-spacing:0.08em;"></div>
          </div>
          <div class="sub-card" style="margin-top:16px;">
            <strong>Participants</strong>
            <ul id="rosterList" class="roster" style="margin-top:12px;"></ul>
            <p id="rosterEmpty" class="muted" style="margin-top:12px;">You're the first one here‚Äîwelcome!</p>
          </div>
          <div id="statusBanner" class="status-banner" style="margin-top:16px;">
            Waiting for the facilitator to launch a question‚Ä¶
          </div>
        </section>
      </div>

      <section class="card canvas-card">
        <div class="canvas-header">
          <div>
            <h2>Creative canvas</h2>
            <p class="subtitle" style="margin-bottom:0;">Go full screen for focus mode and extra drawing space.</p>
          </div>
          <button type="button" class="secondary" style="white-space:nowrap;">Focus mode</button>
        </div>

        <div class="canvas-workspace">
          <nav class="canvas-toolbar" aria-label="Canvas tools">
            <div class="canvas-tool-group" role="group" aria-label="History controls">
              <button type="button" class="canvas-tool-button" id="toolUndo" aria-label="Undo">
                <span class="icon">‚Ü∫</span>
                <span>Undo</span>
              </button>
              <button type="button" class="canvas-tool-button" id="toolRedo" aria-label="Redo">
                <span class="icon">‚Üª</span>
                <span>Redo</span>
              </button>
              <button type="button" class="canvas-tool-button" id="toolClear" aria-label="Delete">
                <span class="icon">üóë</span>
                <span>Clear</span>
              </button>
            </div>

            <div class="canvas-tool-group" role="group" aria-label="Brush tools">
              <button type="button" class="canvas-tool-button is-active" id="toolBrush">
                <span class="icon">‚úèÔ∏è</span>
                <span>Brush</span>
              </button>
              <button type="button" class="canvas-tool-button" id="toolEraser">
                <span class="icon">ü©π</span>
                <span>Eraser</span>
              </button>
              <button type="button" class="canvas-tool-button" id="toolStylus">
                <span class="icon">‚úçÔ∏è</span>
                <span>Stylus</span>
              </button>
            </div>

            <div class="canvas-tool-group" role="group" aria-label="Mode toggles">
              <button type="button" class="canvas-tool-button">
                <span class="icon">üí°</span>
                <span>Ideas</span>
              </button>
              <button type="button" class="canvas-tool-button">
                <span class="icon">üìå</span>
                <span>Pin</span>
              </button>
            </div>
          </nav>

          <div class="canvas-surface" role="presentation">
            <div class="canvas-board" id="canvasBoard">
              <canvas id="canvasPad" aria-label="Freehand drawing surface"></canvas>
              <div class="canvas-placeholder" id="canvasPlaceholder">
                <strong>Your drawing space stays ready.</strong>
                <span>No more floating controls ‚Äî the toolbar stays anchored for easy access.</span>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section id="experienceCard" class="card hidden">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:16px;flex-wrap:wrap;">
          <div>
            <h2 id="questionHeading">Awaiting the next question‚Ä¶</h2>
            <p id="questionMeta" class="muted" style="margin-top:4px;"></p>
          </div>
          <div id="responseSummary" class="sub-card hidden" style="min-width:220px;">
            <strong>Response Progress</strong>
            <p id="responseStats" class="muted" style="margin:8px 0 0;"></p>
          </div>
        </div>

        <div id="choiceArea" class="sub-card" style="margin-top:24px;">
          <div style="display:flex;justify-content:space-between;align-items:center;gap:16px;flex-wrap:wrap;">
            <div>
              <strong id="choiceTitle">Select your option(s)</strong>
              <p id="choiceHint" class="muted" style="margin-top:4px;">Make your selection and submit when ready.</p>
            </div>
            <button id="submitChoice" class="primary" type="button">Submit</button>
          </div>
          <div id="optionsContainer" class="option-list"></div>
          <p id="choiceFeedback" class="muted" style="margin-top:12px;"></p>
        </div>

        <div id="groupArea" class="sub-card hidden" style="margin-top:24px;">
          <strong>Your Discussion Group</strong>
          <p id="groupDescription" class="muted" style="margin-top:6px;"></p>
          <div id="groupMembers" class="group-members" style="margin-top:14px;"></div>
        </div>

        <div id="explanationArea" class="sub-card hidden" style="margin-top:24px;">
          <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
            <strong>Share your reasoning</strong>
            <span id="explanationStatus" class="muted"></span>
          </div>
          <textarea id="explanationInput" placeholder="Capture the thinking behind your choice‚Ä¶"></textarea>
        </div>

        <div id="summaryArea" class="sub-card hidden" style="margin-top:24px;">
          <strong>Session Summary</strong>
          <p class="muted" style="margin-top:6px;">See how the community responded.</p>
          <div id="summaryGrid" class="summary-grid" style="margin-top:16px;"></div>
          <div id="explanationList" style="margin-top:24px;"></div>
        </div>
      </section>
    </div>

    <script src="/env.js"></script>
    <script type="module">
      import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

      const stageLabel = document.getElementById("stageLabel");
      const joinButton = document.getElementById("joinButton");
      const joinCard = document.getElementById("joinCard");
      const statusCard = document.getElementById("statusCard");
      const experienceCard = document.getElementById("experienceCard");
      const joinFeedback = document.getElementById("joinFeedback");
      const statusBanner = document.getElementById("statusBanner");
      const sessionCodeDisplay = document.getElementById("sessionCodeDisplay");
      const rosterList = document.getElementById("rosterList");
      const rosterEmpty = document.getElementById("rosterEmpty");
      const questionHeading = document.getElementById("questionHeading");
      const questionMeta = document.getElementById("questionMeta");
      const optionsContainer = document.getElementById("optionsContainer");
      const submitChoice = document.getElementById("submitChoice");
      const choiceTitle = document.getElementById("choiceTitle");
      const choiceHint = document.getElementById("choiceHint");
      const choiceFeedback = document.getElementById("choiceFeedback");
      const groupArea = document.getElementById("groupArea");
      const groupDescription = document.getElementById("groupDescription");
      const groupMembers = document.getElementById("groupMembers");
      const explanationArea = document.getElementById("explanationArea");
      const explanationInput = document.getElementById("explanationInput");
      const explanationStatus = document.getElementById("explanationStatus");
      const summaryArea = document.getElementById("summaryArea");
      const summaryGrid = document.getElementById("summaryGrid");
      const explanationList = document.getElementById("explanationList");
      const responseSummary = document.getElementById("responseSummary");
      const responseStats = document.getElementById("responseStats");
      const choiceArea = document.getElementById("choiceArea");
      const codeInput = document.getElementById("codeInput");
      const nameInput = document.getElementById("nameInput");
      const canvasBoard = document.getElementById("canvasBoard");
      const canvasPad = document.getElementById("canvasPad");
      const canvasPlaceholder = document.getElementById("canvasPlaceholder");
      const undoButton = document.getElementById("toolUndo");
      const redoButton = document.getElementById("toolRedo");
      const clearButton = document.getElementById("toolClear");
      const brushButton = document.getElementById("toolBrush");
      const eraserButton = document.getElementById("toolEraser");
      const stylusButton = document.getElementById("toolStylus");

      if (canvasBoard && canvasPad) {
        initializeDrawingSurface();
      }

      const state = {
        supabase: null,
        channel: null,
        joined: false,
        studentId: generateId("student"),
        name: "",
        sessionCode: "",
        stage: "LOBBY",
        currentQuestion: null,
        progress: null,
        roster: [],
        selectedChoices: new Set(),
        explanationDraft: "",
      };

      const config = window.__SUPABASE_CONFIG__ || {};
      if (!config.projectUrl || !config.anonKey) {
        displayJoinFeedback("Supabase configuration is missing. Please check the server setup.", true);
        joinButton.disabled = true;
      } else {
        state.supabase = createClient(config.projectUrl, config.anonKey);
      }

      // Prefill session code if provided via URL
      const params = new URLSearchParams(window.location.search);
      if (params.has("code")) {
        codeInput.value = params.get("code");
      }

      joinButton.addEventListener("click", async () => {
        if (!state.supabase || state.joined) return;

        const code = codeInput.value.trim().toUpperCase();
        const name = nameInput.value.trim();
        if (!code || !name) {
          displayJoinFeedback("Please provide both the session code and your name.", true);
          return;
        }

        joinButton.disabled = true;
        displayJoinFeedback("Connecting to the live session‚Ä¶", false, false);

        try {
          state.sessionCode = code;
          state.name = name;
          await connectToChannel();
        } catch (error) {
          console.error(error);
          state.sessionCode = "";
          displayJoinFeedback("We couldn't join that session. Please check the code and try again.", true);
          joinButton.disabled = false;
        }
      });

      submitChoice.addEventListener("click", async () => {
        if (!state.channel || !state.currentQuestion) return;

        const mode = state.currentQuestion.mode;
        const choices = Array.from(state.selectedChoices);

        if (!choices.length) {
          choiceFeedback.textContent = "Select at least one option before submitting.";
          return;
        }

        if (mode !== "multi" && choices.length > 1) {
          choiceFeedback.textContent = "Only one option can be selected for this activity.";
          return;
        }

        const response = await state.channel.send({
          type: "broadcast",
          event: "CHOICE_SUBMIT",
          payload: {
            studentId: state.studentId,
            name: state.name,
            choices,
            submittedAt: new Date().toISOString(),
          },
        });

        if (response?.status === "ok") {
          choiceFeedback.textContent = "Your response is saved. You can resubmit if you change your mind before the next stage.";
        } else {
          choiceFeedback.textContent = "We couldn't deliver your response. Please try again.";
        }
      });

      const debouncedExplanation = debounce(async (value) => {
        if (!state.channel || state.stage !== "EXPLANATION") return;
        state.explanationDraft = value;

        await state.channel.send({
          type: "broadcast",
          event: "EXPLANATION_UPDATE",
          payload: {
            studentId: state.studentId,
            name: state.name,
            explanation: value,
            updatedAt: new Date().toISOString(),
          },
        });
      }, 400);

      explanationInput.addEventListener("input", (event) => {
        debouncedExplanation(event.target.value);
      });

      async function connectToChannel() {
        const channelName = `session-${state.sessionCode}`;
        state.channel = state.supabase.channel(channelName, {
          config: {
            broadcast: { self: false },
            presence: { key: state.studentId },
          },
        });

        state.channel.on("broadcast", { event: "STATE_SYNC" }, ({ payload }) => {
          applyState(payload);
        });

        state.channel.on("broadcast", { event: "SESSION_ENDED" }, ({ payload }) => {
          stageLabel.textContent = "Session Ended";
          statusBanner.textContent = payload?.message || "The facilitator has closed this session.";
          statusBanner.classList.add("error");
          explanationInput.disabled = true;
          submitChoice.disabled = true;
        });

        const { error } = await state.channel.subscribe(async (status) => {
          if (status === "SUBSCRIBED") {
            await state.channel.track({
              role: "student",
              name: state.name,
              studentId: state.studentId,
            });
            onJoinSuccess();
          }
        });

        if (error) {
          throw error;
        }
      }

      function onJoinSuccess() {
        state.joined = true;
        joinCard.classList.add("hidden");
        statusCard.classList.remove("hidden");
        experienceCard.classList.remove("hidden");
        displayJoinFeedback("Successfully connected!", false, true);
        joinButton.disabled = false;
        updateRoster([]);
      }

      function applyState(payload) {
        if (!payload) return;

        state.stage = payload.stage || "LOBBY";
        state.roster = payload.roster || [];
        state.sessionCode = payload.sessionCode || state.sessionCode;
        state.currentQuestion = payload.question || null;
        state.progress = payload.progress || null;

        stageLabel.textContent = stageLabelFor(state.stage, state.currentQuestion?.mode);
        sessionCodeDisplay.textContent = state.sessionCode || "";
        updateRoster(state.roster);
        updateProgressStats(state.progress);

        if (!state.currentQuestion) {
          questionHeading.textContent = "Awaiting the next question‚Ä¶";
          questionMeta.textContent = "You'll be notified as soon as the facilitator launches a new prompt.";
          choiceArea.classList.add("hidden");
          groupArea.classList.add("hidden");
          explanationArea.classList.add("hidden");
          summaryArea.classList.add("hidden");
          return;
        }

        const q = state.currentQuestion;
        questionHeading.textContent = q.text || "Untitled question";
        questionMeta.textContent = `Question ${q.number} ¬∑ ${modeLabel(q.mode)} ¬∑ ${q.optionCount} options`;

        if (state.stage === "CHOICE") {
          renderChoiceInterface(q);
          groupArea.classList.add("hidden");
          explanationArea.classList.add("hidden");
          summaryArea.classList.add("hidden");
          statusBanner.textContent = "Respond to the question, then await further instructions.";
        } else if (state.stage === "GROUP") {
          renderChoiceInterface(q, true);
          renderGroupArea(q);
          explanationArea.classList.add("hidden");
          summaryArea.classList.add("hidden");
          statusBanner.textContent = "You're grouped based on your selections. Connect with your peers.";
        } else if (state.stage === "EXPLANATION") {
          renderGroupArea(q);
          explanationArea.classList.remove("hidden");
          renderExplanationState();
          summaryArea.classList.add("hidden");
          statusBanner.textContent = "Share the thinking behind your choice.";
        } else if (state.stage === "SUMMARY") {
          renderSummary();
          explanationArea.classList.add("hidden");
          statusBanner.textContent = "Review the collective outcomes.";
        } else if (state.stage === "ENDED") {
          statusBanner.textContent = "The facilitator has closed this session.";
          statusBanner.classList.add("error");
          choiceArea.classList.add("hidden");
          groupArea.classList.add("hidden");
          explanationArea.classList.add("hidden");
          summaryArea.classList.add("hidden");
        }
      }

      function renderChoiceInterface(question, isReadOnly = false) {
        choiceArea.classList.remove("hidden");
        choiceTitle.textContent = question.mode === "multi" ? "Select all options that apply" : "Choose the option that best matches your thinking";
        choiceHint.textContent = isReadOnly
          ? "Selections are now closed while we organise groups."
          : question.mode === "multi"
          ? "You can select multiple options. Submit to let the facilitator know you're done."
          : "Select exactly one option. You can resubmit before the next stage.";

        if (isReadOnly) {
          submitChoice.disabled = true;
        } else {
          submitChoice.disabled = false;
        }

        const previousSelection = state.progress?.submissions?.[state.studentId]?.choices || [];
        state.selectedChoices = new Set(previousSelection);

        optionsContainer.innerHTML = "";
        for (let i = 1; i <= question.optionCount; i++) {
          const optionTile = document.createElement("label");
          optionTile.className = "option-tile";

          const control = document.createElement("input");
          control.type = question.mode === "multi" ? "checkbox" : "radio";
          control.name = "optionChoice";
          control.value = String(i);
          control.disabled = isReadOnly;

          const optionLabel = document.createElement("div");
          optionLabel.style.fontWeight = "600";
          optionLabel.textContent = `Option ${i}`;

          if (state.selectedChoices.has(i)) {
            optionTile.classList.add("selected");
            control.checked = true;
          }

          control.addEventListener("change", () => {
            if (question.mode === "multi") {
              if (control.checked) {
                state.selectedChoices.add(i);
              } else {
                state.selectedChoices.delete(i);
              }
            } else {
              state.selectedChoices = new Set([i]);
              document.querySelectorAll('input[name="optionChoice"]').forEach((input) => {
                if (input !== control) {
                  const parent = input.closest(".option-tile");
                  parent && parent.classList.remove("selected");
                  input.checked = false;
                }
              });
            }

            if (control.checked) {
              optionTile.classList.add("selected");
            } else {
              optionTile.classList.remove("selected");
            }
          });

          optionTile.appendChild(optionLabel);
          optionTile.appendChild(control);
          optionsContainer.appendChild(optionTile);
        }

        choiceFeedback.textContent = previousSelection.length
          ? `Submitted: ${previousSelection.map((opt) => `Option ${opt}`).join(", ")}`
          : "";
      }

      function renderGroupArea(question) {
        const mode = question.mode;
        if (mode !== "multi-tier" || !state.progress?.groups) {
          groupArea.classList.add("hidden");
          return;
        }

        groupArea.classList.remove("hidden");
        const mySubmission = state.progress.submissions?.[state.studentId];
        const myChoice = mySubmission?.choices?.[0];
        if (!myChoice) {
          groupDescription.textContent = "We're arranging groups based on your selections.";
          groupMembers.innerHTML = "";
          return;
        }

        const groupInfo = state.progress.groups.find((group) => group.option === myChoice);
        if (!groupInfo) {
          groupDescription.textContent = `We couldn't find your group for Option ${myChoice} yet.`;
          groupMembers.innerHTML = "";
          return;
        }

        groupDescription.textContent = `You're collaborating with peers who chose Option ${myChoice}.`;
        groupMembers.innerHTML = "";

        if (!groupInfo.members.length) {
          groupMembers.innerHTML = `<span class="pill">You're the first one in this group!</span>`;
        } else {
          groupInfo.members.forEach((member) => {
            const pill = document.createElement("span");
            pill.className = "pill";
            pill.textContent = member.name === state.name ? `${member.name} (You)` : member.name;
            groupMembers.appendChild(pill);
          });
        }
      }

      function renderExplanationState() {
        const mySubmission = state.progress?.submissions?.[state.studentId];
        if (!mySubmission) {
          explanationInput.value = "";
          explanationStatus.textContent = "Waiting for your selection.";
          explanationInput.disabled = true;
          return;
        }

        explanationInput.disabled = false;
        explanationInput.value = mySubmission.explanation || state.explanationDraft || "";
        explanationStatus.textContent = mySubmission.explanation
          ? "Saved"
          : "Auto-saves as you type";
      }

      function renderSummary() {
        if (!state.progress) return;

        choiceArea.classList.add("hidden");
        groupArea.classList.add("hidden");
        summaryArea.classList.remove("hidden");

        summaryGrid.innerHTML = "";
        const counts = state.progress.counts || [];
        const total = counts.reduce((sum, c) => sum + c, 0) || 1;

        counts.forEach((count, index) => {
          const card = document.createElement("div");
          card.className = "sub-card";
          const label = document.createElement("div");
          label.innerHTML = `<strong>Option ${index + 1}</strong>`;

          const value = document.createElement("div");
          value.style.marginTop = "8px";
          value.innerHTML = `<span style="font-size:1.8rem;font-weight:700;">${count}</span> <span class="muted">responses</span>`;

          const progressTrack = document.createElement("div");
          progressTrack.className = "progress-track";
          const bar = document.createElement("div");
          bar.className = "progress-bar";
          bar.style.width = `${Math.round((count / total) * 100)}%`;
          progressTrack.appendChild(bar);

          card.appendChild(label);
          card.appendChild(value);
          card.appendChild(progressTrack);
          summaryGrid.appendChild(card);
        });

        explanationList.innerHTML = "";
        if (state.currentQuestion.mode === "multi-tier") {
          const explanations = state.progress.explanations || [];
          if (!explanations.length) {
            explanationList.innerHTML = `<p class="muted">Explanations will appear here once shared.</p>`;
          } else {
            const title = document.createElement("h3");
            title.textContent = "Shared Reasoning";
            explanationList.appendChild(title);

            explanations.forEach((item) => {
              const block = document.createElement("div");
              block.className = "sub-card";
              block.style.marginTop = "12px";
              block.innerHTML = `<strong>${item.name}</strong> ¬∑ Option ${item.option || "‚Äì"}<p class="muted" style="margin-top:8px;white-space:pre-wrap;">${item.explanation}</p>`;
              explanationList.appendChild(block);
            });
          }
        } else {
          explanationList.innerHTML = "";
        }
      }

      function updateRoster(roster) {
        rosterList.innerHTML = "";
        if (!roster || !roster.length) {
          rosterEmpty.classList.remove("hidden");
          return;
        }
        rosterEmpty.classList.add("hidden");

        roster
          .filter((member) => member && member.name)
          .forEach((member) => {
            const li = document.createElement("li");
            li.textContent = member.name;
            rosterList.appendChild(li);
          });
      }

      function updateProgressStats(progress) {
        if (!progress || !state.roster) {
          responseSummary.classList.add("hidden");
          return;
        }

        const totalParticipants = state.roster.length;
        const submitted = Object.values(progress.submissions || {}).filter((entry) => (entry.choices || []).length).length;
        responseStats.textContent = `${submitted} of ${totalParticipants} participants have responded.`;
        responseSummary.classList.remove("hidden");
      }

      function displayJoinFeedback(message, isError = false, isSuccess = false) {
        if (!message) {
          joinFeedback.classList.add("hidden");
          return;
        }
        joinFeedback.textContent = message;
        joinFeedback.classList.remove("hidden", "error", "success");
        if (isError) joinFeedback.classList.add("error");
        if (isSuccess) joinFeedback.classList.add("success");
      }

      function stageLabelFor(stage, mode) {
        switch (stage) {
          case "CHOICE":
            return mode === "multi-tier" ? "Select" : "Respond";
          case "GROUP":
            return "Group";
          case "EXPLANATION":
            return "Explain";
          case "SUMMARY":
            return "Summary";
          case "ENDED":
            return "Session Ended";
          default:
            return "Lobby";
        }
      }

      function modeLabel(mode) {
        switch (mode) {
          case "single":
            return "Single response";
          case "multi":
            return "Multi-response";
          case "multi-tier":
            return "Multi-tier";
          default:
            return "";
        }
      }

      function debounce(fn, delay) {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => fn(...args), delay);
        };
      }

      function generateId(prefix) {
        if (typeof crypto !== "undefined" && crypto.randomUUID) {
          return `${prefix}-${crypto.randomUUID()}`;
        }
        return `${prefix}-${Math.random().toString(16).slice(2)}${Date.now()}`;
      }

      function initializeDrawingSurface() {
        const ctx = canvasPad.getContext("2d");
        if (!ctx) return;

        const drawingState = {
          strokes: [],
          undone: [],
          active: new Map(),
          tool: {
            mode: "draw",
            color: "#222945",
            size: 4.2,
          },
        };

        const brushTool = { mode: "draw", color: "#222945", size: 4.2 };
        const stylusTool = { mode: "draw", color: "#222945", size: 2.4 };
        const eraserTool = { mode: "erase", color: "#ffffff", size: 18 };

        const toolOptions = [
          { button: brushButton, tool: brushTool },
          { button: stylusButton, tool: stylusTool },
          { button: eraserButton, tool: eraserTool },
        ];

        let activeToolButton = brushButton;

        toolOptions.forEach(({ button, tool }) => {
          if (!button) return;
          button.addEventListener("click", () => {
            drawingState.tool = { ...tool };
            if (activeToolButton && activeToolButton !== button) {
              activeToolButton.classList.remove("is-active");
            }
            button.classList.add("is-active");
            activeToolButton = button;
          });
        });

        canvasPad.style.cursor = "crosshair";
        canvasPad.style.touchAction = "none";

        if (typeof ResizeObserver !== "undefined") {
          const resizeObserver = new ResizeObserver(() => resizeCanvas());
          resizeObserver.observe(canvasBoard);
        }
        window.addEventListener("resize", () => resizeCanvas());
        window.addEventListener("orientationchange", () => setTimeout(resizeCanvas, 120));

        canvasPad.addEventListener("pointerdown", handlePointerDown);
        canvasPad.addEventListener("pointermove", handlePointerMove);
        canvasPad.addEventListener("pointerup", handlePointerUp);
        canvasPad.addEventListener("pointercancel", handlePointerUp);

        undoButton?.addEventListener("click", () => {
          if (!drawingState.strokes.length) return;
          const stroke = drawingState.strokes.pop();
          if (stroke) {
            drawingState.undone.push(stroke);
            renderCanvas();
          }
        });

        redoButton?.addEventListener("click", () => {
          if (!drawingState.undone.length) return;
          const stroke = drawingState.undone.pop();
          if (stroke) {
            drawingState.strokes.push(stroke);
            renderCanvas();
          }
        });

        clearButton?.addEventListener("click", () => {
          if (!drawingState.strokes.length && !drawingState.active.size) return;
          drawingState.strokes = [];
          drawingState.undone = [];
          renderCanvas();
        });

        resizeCanvas();

        function resizeCanvas() {
          const rect = canvasBoard.getBoundingClientRect();
          if (!rect.width || !rect.height) return;

          const ratio = window.devicePixelRatio || 1;
          canvasPad.width = rect.width * ratio;
          canvasPad.height = rect.height * ratio;
          canvasPad.style.width = `${rect.width}px`;
          canvasPad.style.height = `${rect.height}px`;

          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.scale(ratio, ratio);
          renderCanvas();
        }

        function handlePointerDown(event) {
          event.preventDefault();
          canvasPad.setPointerCapture(event.pointerId);
          drawingState.undone = [];
          const point = translatePoint(event);
          const pressure = normalisePressure(event);
          const stroke = {
            points: [point],
            avgPressure: pressure,
            color: drawingState.tool.color,
            size: drawingState.tool.size,
            composite: drawingState.tool.mode === "erase" ? "destination-out" : "source-over",
          };
          drawingState.active.set(event.pointerId, stroke);
          renderCanvas();
        }

        function handlePointerMove(event) {
          const stroke = drawingState.active.get(event.pointerId);
          if (!stroke) return;
          const nextPoint = translatePoint(event);
          const lastPoint = stroke.points[stroke.points.length - 1];
          if (!lastPoint) return;
          const distance = Math.hypot(nextPoint.x - lastPoint.x, nextPoint.y - lastPoint.y);
          if (distance < 0.4) return;
          const pressure = normalisePressure(event);
          stroke.points.push(nextPoint);
          stroke.avgPressure =
            (stroke.avgPressure * (stroke.points.length - 1) + pressure) / stroke.points.length;
          renderCanvas();
        }

        function handlePointerUp(event) {
          const stroke = drawingState.active.get(event.pointerId);
          if (!stroke) {
            if (canvasPad.hasPointerCapture(event.pointerId)) {
              canvasPad.releasePointerCapture(event.pointerId);
            }
            return;
          }

          const finalPoint = translatePoint(event);
          const lastPoint = stroke.points[stroke.points.length - 1];
          if (lastPoint && (lastPoint.x !== finalPoint.x || lastPoint.y !== finalPoint.y)) {
            stroke.points.push(finalPoint);
          }

          drawingState.active.delete(event.pointerId);
          if (stroke.points.length) {
            drawingState.strokes.push(stroke);
          }
          if (canvasPad.hasPointerCapture(event.pointerId)) {
            canvasPad.releasePointerCapture(event.pointerId);
          }
          renderCanvas();
        }

        function renderCanvas() {
          ctx.clearRect(0, 0, canvasPad.width, canvasPad.height);
          drawingState.strokes.forEach((stroke) => paintStroke(stroke));
          drawingState.active.forEach((stroke) => paintStroke(stroke));
          updatePlaceholderVisibility();
          updateToolbarState();
        }

        function paintStroke(stroke) {
          if (!stroke.points.length) return;

          ctx.save();
          ctx.globalCompositeOperation = stroke.composite;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          const width = stroke.size * (0.45 + (stroke.avgPressure || 0.5) * 0.9);
          ctx.lineWidth = width;
          ctx.strokeStyle = stroke.composite === "destination-out" ? "rgba(0,0,0,1)" : stroke.color;

          if (stroke.points.length === 1) {
            const point = stroke.points[0];
            ctx.beginPath();
            ctx.arc(point.x, point.y, width / 2, 0, Math.PI * 2);
            if (stroke.composite === "destination-out") {
              ctx.fillStyle = "rgba(0,0,0,1)";
            } else {
              ctx.fillStyle = stroke.color;
            }
            ctx.fill();
            ctx.restore();
            return;
          }

          ctx.beginPath();
          ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
          for (let i = 1; i < stroke.points.length; i++) {
            const previous = stroke.points[i - 1];
            const current = stroke.points[i];
            const midX = (previous.x + current.x) / 2;
            const midY = (previous.y + current.y) / 2;
            ctx.quadraticCurveTo(previous.x, previous.y, midX, midY);
          }
          ctx.stroke();
          ctx.restore();
        }

        function translatePoint(event) {
          const rect = canvasPad.getBoundingClientRect();
          return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
          };
        }

        function normalisePressure(event) {
          if (typeof event.pressure === "number" && event.pressure > 0) {
            return Math.min(1, Math.max(event.pressure, 0.1));
          }
          return event.pointerType === "pen" ? 0.7 : 0.45;
        }

        function updatePlaceholderVisibility() {
          if (!canvasPlaceholder) return;
          const shouldHide = drawingState.strokes.length > 0 || drawingState.active.size > 0;
          canvasPlaceholder.classList.toggle("hidden", shouldHide);
        }

        function updateToolbarState() {
          const hasStrokes = drawingState.strokes.length > 0;
          const hasUndone = drawingState.undone.length > 0;
          if (undoButton) undoButton.disabled = !hasStrokes;
          if (redoButton) redoButton.disabled = !hasUndone;
          if (clearButton) clearButton.disabled = !hasStrokes && drawingState.active.size === 0;
        }
      }
    </script>
  </body>
</html>
